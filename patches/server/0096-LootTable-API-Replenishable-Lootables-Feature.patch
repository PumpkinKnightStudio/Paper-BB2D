From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Sun, 1 May 2016 21:19:14 -0400
Subject: [PATCH] LootTable API & Replenishable Lootables Feature

Provides an API to control the loot table for an object.
Also provides a feature that any Lootable Inventory (Chests in Structures)
can automatically replenish after a given time.

This feature is good for long term worlds so that newer players
do not suffer with "Every chest has been looted"

== AT ==
public org.bukkit.craftbukkit.block.CraftBlockEntityState getTileEntity()Lnet/minecraft/world/level/block/entity/BlockEntity;
public org.bukkit.craftbukkit.block.CraftLootable setLootTable(Lorg/bukkit/loot/LootTable;J)V
public org.bukkit.craftbukkit.entity.CraftMinecartContainer setLootTable(Lorg/bukkit/loot/LootTable;J)V

diff --git a/src/main/java/com/destroystokyo/paper/loottable/PaperLootable.java b/src/main/java/com/destroystokyo/paper/loottable/PaperLootable.java
new file mode 100644
index 0000000000000000000000000000000000000000..a53d51be1da25b87f2bc0a29a196d8f9996dbd2b
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/loottable/PaperLootable.java
@@ -0,0 +1,21 @@
+package com.destroystokyo.paper.loottable;
+
+import org.bukkit.loot.LootTable;
+import org.bukkit.loot.Lootable;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+@DefaultQualifier(NonNull.class)
+public interface PaperLootable extends Lootable {
+
+    @Override
+    default void setLootTable(final @Nullable LootTable table) {
+        this.setLootTable(table, this.getSeed());
+    }
+
+    @Override
+    default void setSeed(final long seed) {
+        this.setLootTable(this.getLootTable(), seed);
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/loottable/PaperLootableBlock.java b/src/main/java/com/destroystokyo/paper/loottable/PaperLootableBlock.java
new file mode 100644
index 0000000000000000000000000000000000000000..132c7d256dfb3d18be2955c87ab034dcddf4c7d0
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/loottable/PaperLootableBlock.java
@@ -0,0 +1,35 @@
+package com.destroystokyo.paper.loottable;
+
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.RandomizableContainer;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.util.CraftNamespacedKey;
+import org.bukkit.loot.LootTable;
+import org.checkerframework.checker.nullness.qual.Nullable;
+
+public interface PaperLootableBlock extends PaperLootable {
+
+    RandomizableContainer getRandomizableContainer();
+
+    /* Lootable */
+    @Override
+    default @Nullable LootTable getLootTable() {
+        if (this.getRandomizableContainer().getLootTable() == null) {
+            return null;
+        }
+
+        final ResourceLocation key = this.getRandomizableContainer().getLootTable();
+        return Bukkit.getLootTable(CraftNamespacedKey.fromMinecraft(key));
+    }
+
+    @Override
+    default void setLootTable(final @Nullable LootTable table, final long seed) {
+        final @Nullable ResourceLocation key = (table == null) ? null : CraftNamespacedKey.toMinecraft(table.getKey());
+        this.getRandomizableContainer().setLootTable(key, seed);
+    }
+
+    @Override
+    default long getSeed() {
+        return this.getRandomizableContainer().getLootTableSeed();
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/loottable/PaperLootableBlockInventory.java b/src/main/java/com/destroystokyo/paper/loottable/PaperLootableBlockInventory.java
new file mode 100644
index 0000000000000000000000000000000000000000..114c05f234442a05a23ae1bea745894541b37559
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/loottable/PaperLootableBlockInventory.java
@@ -0,0 +1,33 @@
+package com.destroystokyo.paper.loottable;
+
+import java.util.Objects;
+import net.minecraft.core.BlockPos;
+import net.minecraft.world.level.Level;
+import org.bukkit.Chunk;
+import org.bukkit.block.Block;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+@DefaultQualifier(NonNull.class)
+public interface PaperLootableBlockInventory extends LootableBlockInventory, PaperLootableInventory, PaperLootableBlock {
+
+    /* PaperLootableInventory */
+    @Override
+    default Level getNMSWorld() {
+        return Objects.requireNonNull(this.getRandomizableContainer().getLevel(), "Cannot manage loot tables on a block entity without a world");
+    }
+
+    @Override
+    default PaperLootableInventoryData lootableData() {
+        return Objects.requireNonNull(this.getRandomizableContainer().lootableData(), "Can only manage loot tables on tile entities with lootableData");
+    }
+
+    /* LootableBlockInventory */
+    @Override
+    default Block getBlock() {
+        final BlockPos position = this.getRandomizableContainer().getBlockPos();
+        final Chunk bukkitChunk = this.getBukkitWorld().getChunkAt(org.bukkit.craftbukkit.block.CraftBlock.at(this.getNMSWorld(), position));
+        return bukkitChunk.getBlock(position.getX(), position.getY(), position.getZ());
+    }
+
+}
diff --git a/src/main/java/com/destroystokyo/paper/loottable/PaperLootableEntity.java b/src/main/java/com/destroystokyo/paper/loottable/PaperLootableEntity.java
new file mode 100644
index 0000000000000000000000000000000000000000..0d7bb7b23a84351d75060089b6e0037ebfed3b75
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/loottable/PaperLootableEntity.java
@@ -0,0 +1,37 @@
+package com.destroystokyo.paper.loottable;
+
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.entity.vehicle.ContainerEntity;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.util.CraftNamespacedKey;
+import org.bukkit.loot.LootTable;
+import org.bukkit.loot.Lootable;
+import org.checkerframework.checker.nullness.qual.Nullable;
+
+public interface PaperLootableEntity extends Lootable {
+
+    ContainerEntity getHandle();
+
+    /* Lootable */
+    @Override
+    default @Nullable LootTable getLootTable() {
+        if (this.getHandle().getLootTable() == null) {
+            return null;
+        }
+
+        final ResourceLocation key = this.getHandle().getLootTable();
+        return Bukkit.getLootTable(CraftNamespacedKey.fromMinecraft(key));
+    }
+
+    @Override
+    default void setLootTable(final @Nullable LootTable table, final long seed) {
+        final @Nullable ResourceLocation key = (table == null) ? null : CraftNamespacedKey.toMinecraft(table.getKey());
+        this.getHandle().setLootTable(key);
+        this.getHandle().setLootTableSeed(seed);
+    }
+
+    @Override
+    default long getSeed() {
+        return this.getHandle().getLootTableSeed();
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/loottable/PaperLootableEntityInventory.java b/src/main/java/com/destroystokyo/paper/loottable/PaperLootableEntityInventory.java
new file mode 100644
index 0000000000000000000000000000000000000000..726f8e6561bc4675a83d3b98b7dc33b20b4db01f
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/loottable/PaperLootableEntityInventory.java
@@ -0,0 +1,26 @@
+package com.destroystokyo.paper.loottable;
+
+import net.minecraft.world.level.Level;
+import org.bukkit.entity.Entity;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+@DefaultQualifier(NonNull.class)
+public interface PaperLootableEntityInventory extends LootableEntityInventory, PaperLootableInventory, PaperLootableEntity {
+
+    /* PaperLootableInventory */
+    @Override
+    default Level getNMSWorld() {
+        return this.getHandle().level();
+    }
+
+    @Override
+    default PaperLootableInventoryData lootableData() {
+        return this.getHandle().lootableData();
+    }
+
+    /* LootableEntityInventory */
+    default Entity getEntity() {
+        return ((net.minecraft.world.entity.Entity) this.getHandle()).getBukkitEntity();
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/loottable/PaperLootableInventory.java b/src/main/java/com/destroystokyo/paper/loottable/PaperLootableInventory.java
new file mode 100644
index 0000000000000000000000000000000000000000..9283be98adb4711526707b7eb048b3496366f785
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/loottable/PaperLootableInventory.java
@@ -0,0 +1,79 @@
+package com.destroystokyo.paper.loottable;
+
+import java.util.UUID;
+import net.minecraft.world.level.Level;
+import org.bukkit.World;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+@DefaultQualifier(NonNull.class)
+public interface PaperLootableInventory extends PaperLootable, LootableInventory {
+
+    /* impl */
+    PaperLootableInventoryData lootableData();
+
+    Level getNMSWorld();
+
+    default World getBukkitWorld() {
+        return this.getNMSWorld().getWorld();
+    }
+
+    /* LootableInventory */
+    @Override
+    default boolean isRefillEnabled() {
+        return this.getNMSWorld().paperConfig().lootables.autoReplenish;
+    }
+
+    @Override
+    default boolean hasBeenFilled() {
+        return this.getLastFilled() != -1;
+    }
+
+    @Override
+    default boolean hasPlayerLooted(final UUID player) {
+        return this.lootableData().hasPlayerLooted(player);
+    }
+
+    @Override
+    default boolean canPlayerLoot(final UUID player) {
+        return this.lootableData().canPlayerLoot(player, this.getNMSWorld().paperConfig());
+    }
+
+    @Override
+    default Long getLastLooted(final UUID player) {
+        return this.lootableData().getLastLooted(player);
+    }
+
+    @Override
+    default boolean setHasPlayerLooted(final UUID player, final boolean looted) {
+        final boolean hasLooted = this.hasPlayerLooted(player);
+        if (hasLooted != looted) {
+            this.lootableData().setPlayerLootedState(player, looted);
+        }
+        return hasLooted;
+    }
+
+    @Override
+    default boolean hasPendingRefill() {
+        final long nextRefill = this.lootableData().getNextRefill();
+        return nextRefill != -1 && nextRefill > this.lootableData().getLastFill();
+    }
+
+    @Override
+    default long getLastFilled() {
+        return this.lootableData().getLastFill();
+    }
+
+    @Override
+    default long getNextRefill() {
+        return this.lootableData().getNextRefill();
+    }
+
+    @Override
+    default long setNextRefill(long refillAt) {
+        if (refillAt < -1) {
+            refillAt = -1;
+        }
+        return this.lootableData().setNextRefill(refillAt);
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/loottable/PaperLootableInventoryData.java b/src/main/java/com/destroystokyo/paper/loottable/PaperLootableInventoryData.java
new file mode 100644
index 0000000000000000000000000000000000000000..8d7e9070d752e893cb51d29910fd3639f55b6075
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/loottable/PaperLootableInventoryData.java
@@ -0,0 +1,193 @@
+package com.destroystokyo.paper.loottable;
+
+import io.papermc.paper.configuration.WorldConfiguration;
+import io.papermc.paper.configuration.type.DurationOrDisabled;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Random;
+import java.util.UUID;
+import java.util.concurrent.TimeUnit;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.ListTag;
+import net.minecraft.nbt.Tag;
+import org.bukkit.entity.Player;
+import org.bukkit.loot.LootTable;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+@DefaultQualifier(NonNull.class)
+public class PaperLootableInventoryData {
+
+    private static final Random RANDOM = new Random();
+
+    private long lastFill = -1;
+    private long nextRefill = -1;
+    private int numRefills = 0;
+    private @Nullable Map<UUID, Long> lootedPlayers;
+
+    long getLastFill() {
+        return this.lastFill;
+    }
+
+    long getNextRefill() {
+        return this.nextRefill;
+    }
+
+    long setNextRefill(final long nextRefill) {
+        final long prev = this.nextRefill;
+        this.nextRefill = nextRefill;
+        return prev;
+    }
+
+    public boolean shouldReplenish(final PaperLootableInventory lootable, final net.minecraft.world.entity.player.@Nullable Player player) {
+        final @Nullable LootTable table = lootable.getLootTable();
+
+        // No Loot Table associated
+        if (table == null) {
+            return false;
+        }
+
+        // ALWAYS process the first fill or if the feature is disabled
+        if (this.lastFill == -1 || !lootable.getNMSWorld().paperConfig().lootables.autoReplenish) {
+            return true;
+        }
+
+        // Only process refills when a player is set
+        if (player == null) {
+            return false;
+        }
+
+        // Chest is not scheduled for refill
+        if (this.nextRefill == -1) {
+            return false;
+        }
+
+        final WorldConfiguration paperConfig = lootable.getNMSWorld().paperConfig();
+
+        // Check if max refills has been hit
+        if (paperConfig.lootables.maxRefills != -1 && this.numRefills >= paperConfig.lootables.maxRefills) {
+            return false;
+        }
+
+        // Refill has not been reached
+        if (this.nextRefill > System.currentTimeMillis()) {
+            return false;
+        }
+
+
+        final Player bukkitPlayer = (Player) player.getBukkitEntity();
+        final LootableInventoryReplenishEvent event = new LootableInventoryReplenishEvent(bukkitPlayer, lootable);
+        event.setCancelled(!this.canPlayerLoot(player.getUUID(), paperConfig));
+        return event.callEvent();
+    }
+
+    public void processRefill(final PaperLootableInventory lootable, final net.minecraft.world.entity.player.@Nullable Player player) {
+        this.lastFill = System.currentTimeMillis();
+        final WorldConfiguration paperConfig = lootable.getNMSWorld().paperConfig();
+        if (paperConfig.lootables.autoReplenish) {
+            final long min = paperConfig.lootables.refreshMin.seconds();
+            final long max = paperConfig.lootables.refreshMax.seconds();
+            this.nextRefill = this.lastFill + (min + RANDOM.nextLong(max - min + 1)) * 1000L;
+            this.numRefills++;
+            if (paperConfig.lootables.resetSeedOnFill) {
+                lootable.setSeed(0);
+            }
+            if (player != null) { // This means that numRefills can be incremented without a player being in the lootedPlayers list - Seems to be EntityMinecartChest specific
+                this.setPlayerLootedState(player.getUUID(), true);
+            }
+        } else {
+            lootable.clearLootTable();
+        }
+    }
+
+    private static final String ROOT = "Paper.LootableData";
+    private static final String LAST_FILL = "lastFill";
+    private static final String NEXT_REFILL = "nextRefill";
+    private static final String NUM_REFILLS = "numRefills";
+    private static final String LOOTED_PLAYERS = "lootedPlayers";
+
+    public void loadNbt(final CompoundTag base) {
+        if (!base.contains(ROOT, Tag.TAG_COMPOUND)) {
+            return;
+        }
+        final CompoundTag comp = base.getCompound(ROOT);
+        if (comp.contains(LAST_FILL)) {
+            this.lastFill = comp.getLong(LAST_FILL);
+        }
+        if (comp.contains(NEXT_REFILL)) {
+            this.nextRefill = comp.getLong(NEXT_REFILL);
+        }
+
+        if (comp.contains(NUM_REFILLS)) {
+            this.numRefills = comp.getInt(NUM_REFILLS);
+        }
+        if (comp.contains(LOOTED_PLAYERS, Tag.TAG_LIST)) {
+            final ListTag list = comp.getList(LOOTED_PLAYERS, Tag.TAG_COMPOUND);
+            final int size = list.size();
+            if (size > 0) {
+                this.lootedPlayers = new HashMap<>(list.size());
+            }
+            for (int i = 0; i < size; i++) {
+                final CompoundTag cmp = list.getCompound(i);
+                this.lootedPlayers.put(cmp.getUUID("UUID"), cmp.getLong("Time"));
+            }
+        }
+    }
+
+    public void saveNbt(final CompoundTag base) {
+        final CompoundTag comp = new CompoundTag();
+        if (this.nextRefill != -1) {
+            comp.putLong(NEXT_REFILL, this.nextRefill);
+        }
+        if (this.lastFill != -1) {
+            comp.putLong(LAST_FILL, this.lastFill);
+        }
+        if (this.numRefills != 0) {
+            comp.putInt(NUM_REFILLS, this.numRefills);
+        }
+        if (this.lootedPlayers != null && !this.lootedPlayers.isEmpty()) {
+            final ListTag list = new ListTag();
+            for (final Map.Entry<UUID, Long> entry : this.lootedPlayers.entrySet()) {
+                final CompoundTag cmp = new CompoundTag();
+                cmp.putUUID("UUID", entry.getKey());
+                cmp.putLong("Time", entry.getValue());
+                list.add(cmp);
+            }
+            comp.put(LOOTED_PLAYERS, list);
+        }
+
+        if (!comp.isEmpty()) {
+            base.put(ROOT, comp);
+        }
+    }
+
+    void setPlayerLootedState(final UUID player, final boolean looted) {
+        if (looted && this.lootedPlayers == null) {
+            this.lootedPlayers = new HashMap<>();
+        }
+        if (looted) {
+            this.lootedPlayers.put(player, System.currentTimeMillis());
+        } else if (this.lootedPlayers != null) {
+            this.lootedPlayers.remove(player);
+        }
+    }
+
+    boolean canPlayerLoot(final UUID player, final WorldConfiguration worldConfiguration) {
+        final @Nullable Long lastLooted = this.getLastLooted(player);
+        if (!worldConfiguration.lootables.restrictPlayerReloot || lastLooted == null) return true;
+
+        final DurationOrDisabled restrictPlayerRelootTime = worldConfiguration.lootables.restrictPlayerRelootTime;
+        if (restrictPlayerRelootTime.value().isEmpty()) return false;
+
+        return TimeUnit.SECONDS.toMillis(restrictPlayerRelootTime.value().get().seconds()) + lastLooted < System.currentTimeMillis();
+    }
+
+    boolean hasPlayerLooted(final UUID player) {
+        return this.lootedPlayers != null && this.lootedPlayers.containsKey(player);
+    }
+
+    @Nullable Long getLastLooted(final UUID player) {
+        return this.lootedPlayers != null ? this.lootedPlayers.get(player) : null;
+    }
+}
diff --git a/src/main/java/net/minecraft/world/RandomizableContainer.java b/src/main/java/net/minecraft/world/RandomizableContainer.java
index 22eba5982dd258e2f58a7a70fd25900364cc9448..504f51b8f1bbb7589ed6d43ff41f9bbbbbbb895c 100644
--- a/src/main/java/net/minecraft/world/RandomizableContainer.java
+++ b/src/main/java/net/minecraft/world/RandomizableContainer.java
@@ -27,7 +27,7 @@ public interface RandomizableContainer extends Container {
 
     void setLootTable(@Nullable ResourceLocation lootTableId);
 
-    default void setLootTable(ResourceLocation lootTableId, long lootTableSeed) {
+    default void setLootTable(@Nullable ResourceLocation lootTableId, long lootTableSeed) { // Paper - add nullable
         this.setLootTable(lootTableId);
         this.setLootTableSeed(lootTableSeed);
     }
@@ -50,16 +50,18 @@ public interface RandomizableContainer extends Container {
     }
 
     default boolean tryLoadLootTable(CompoundTag nbt) {
+        if (this.lootableData() != null) this.lootableData().loadNbt(nbt); // Paper - LootTable API
         if (nbt.contains("LootTable", 8)) {
             this.setLootTable(new ResourceLocation(nbt.getString("LootTable")));
             this.setLootTableSeed(nbt.getLong("LootTableSeed"));
-            return true;
+            return this.lootableData() == null; // Paper - only track the loot table if there is chance for replenish
         } else {
             return false;
         }
     }
 
     default boolean trySaveLootTable(CompoundTag nbt) {
+        if (this.lootableData() != null) this.lootableData().saveNbt(nbt); // Paper - LootTable API
         ResourceLocation resourceLocation = this.getLootTable();
         if (resourceLocation == null) {
             return false;
@@ -70,7 +72,7 @@ public interface RandomizableContainer extends Container {
                 nbt.putLong("LootTableSeed", l);
             }
 
-            return true;
+            return this.lootableData() == null; // Paper - only track the loot table if there is chance for replenish
         }
     }
 
@@ -78,13 +80,19 @@ public interface RandomizableContainer extends Container {
         Level level = this.getLevel();
         BlockPos blockPos = this.getBlockPos();
         ResourceLocation resourceLocation = this.getLootTable();
-        if (resourceLocation != null && level != null && level.getServer() != null) {
+        if (resourceLocation != null && level != null && level.getServer() != null && (this.lootableData() == null || this.lootableData().shouldReplenish(this.getLootableInventory(), player))) { // Paper - LootTable API
             LootTable lootTable = level.getServer().getLootData().getLootTable(resourceLocation);
             if (player instanceof ServerPlayer) {
                 CriteriaTriggers.GENERATE_LOOT.trigger((ServerPlayer)player, resourceLocation);
             }
 
-            this.setLootTable((ResourceLocation)null);
+            // Paper start - LootTable API
+            if (this.lootableData() == null) {
+                this.setLootTable((ResourceLocation)null);
+            } else {
+                this.lootableData().processRefill(this.getLootableInventory(), player);
+            }
+            // Paper end - LootTable API
             LootParams.Builder builder = (new LootParams.Builder((ServerLevel)level)).withParameter(LootContextParams.ORIGIN, Vec3.atCenterOf(blockPos));
             if (player != null) {
                 builder.withLuck(player.getLuck()).withParameter(LootContextParams.THIS_ENTITY, player);
@@ -94,4 +102,15 @@ public interface RandomizableContainer extends Container {
         }
 
     }
+
+    // Paper start - LootTable API
+    @Nullable @org.jetbrains.annotations.Contract(pure = true)
+    default com.destroystokyo.paper.loottable.PaperLootableInventoryData lootableData() {
+        return null; // some containers don't really have a "replenish" ability like decorated pots
+    }
+
+    default com.destroystokyo.paper.loottable.PaperLootableInventory getLootableInventory() {
+        return (com.destroystokyo.paper.loottable.PaperLootableInventory) java.util.Objects.requireNonNull(this.getLevel(), "Cannot manage loot tables on block entities not in world").getWorld().getBlockState(io.papermc.paper.util.MCUtil.toLocation(this.getLevel(), this.getBlockPos()));
+    }
+    // Paper end - LootTable API
 }
diff --git a/src/main/java/net/minecraft/world/entity/vehicle/AbstractMinecartContainer.java b/src/main/java/net/minecraft/world/entity/vehicle/AbstractMinecartContainer.java
index 364cfa220b5c7c5351f1eb909066bef933da2c08..a63dbc484c9ccda38db47615283066fcb644b1a9 100644
--- a/src/main/java/net/minecraft/world/entity/vehicle/AbstractMinecartContainer.java
+++ b/src/main/java/net/minecraft/world/entity/vehicle/AbstractMinecartContainer.java
@@ -32,6 +32,14 @@ public abstract class AbstractMinecartContainer extends AbstractMinecart impleme
     public ResourceLocation lootTable;
     public long lootTableSeed;
 
+    // Paper start - LootTable API
+    final com.destroystokyo.paper.loottable.PaperLootableInventoryData lootableData = new com.destroystokyo.paper.loottable.PaperLootableInventoryData();
+
+    @Override
+    public com.destroystokyo.paper.loottable.PaperLootableInventoryData lootableData() {
+        return this.lootableData;
+    }
+    // Paper end - LootTable API
     // CraftBukkit start
     public List<HumanEntity> transaction = new java.util.ArrayList<HumanEntity>();
     private int maxStack = MAX_STACK;
diff --git a/src/main/java/net/minecraft/world/entity/vehicle/ChestBoat.java b/src/main/java/net/minecraft/world/entity/vehicle/ChestBoat.java
index 7bfdffc9b3c637bd6ac8ac3eb10961abdc5b1a7a..414f7ad6317d9cea607b29a7af3cddaad6820b6b 100644
--- a/src/main/java/net/minecraft/world/entity/vehicle/ChestBoat.java
+++ b/src/main/java/net/minecraft/world/entity/vehicle/ChestBoat.java
@@ -198,7 +198,7 @@ public class ChestBoat extends Boat implements HasCustomInventoryScreen, Contain
     @Nullable
     @Override
     public AbstractContainerMenu createMenu(int syncId, Inventory playerInventory, Player player) {
-        if (this.lootTable != null && player.isSpectator()) {
+        if (this.lootTable != null && player.isSpectator()) { // Paper - LootTable API (TODO spectators can open chests that aren't ready to be re-generated but this doesn't support that)
             return null;
         } else {
             this.unpackLootTable(playerInventory.player);
@@ -246,6 +246,14 @@ public class ChestBoat extends Boat implements HasCustomInventoryScreen, Contain
         this.level().gameEvent(GameEvent.CONTAINER_CLOSE, this.position(), GameEvent.Context.of((Entity) player));
     }
 
+    // Paper start - LootTable API
+    final com.destroystokyo.paper.loottable.PaperLootableInventoryData lootableData = new com.destroystokyo.paper.loottable.PaperLootableInventoryData();
+
+    @Override
+    public com.destroystokyo.paper.loottable.PaperLootableInventoryData lootableData() {
+        return this.lootableData;
+    }
+    // Paper end - LootTable API
     // CraftBukkit start
     public List<HumanEntity> transaction = new java.util.ArrayList<HumanEntity>();
     private int maxStack = MAX_STACK;
diff --git a/src/main/java/net/minecraft/world/entity/vehicle/ContainerEntity.java b/src/main/java/net/minecraft/world/entity/vehicle/ContainerEntity.java
index e0fbacd574e0c83c2e1d164ded8e9ccf4af30480..bed48a0e7e4e31557d0ba6b90737276245c0e24e 100644
--- a/src/main/java/net/minecraft/world/entity/vehicle/ContainerEntity.java
+++ b/src/main/java/net/minecraft/world/entity/vehicle/ContainerEntity.java
@@ -54,26 +54,26 @@ public interface ContainerEntity extends Container, MenuProvider {
     }
 
     default void addChestVehicleSaveData(CompoundTag nbt) {
+        this.lootableData().saveNbt(nbt); // Paper
         if (this.getLootTable() != null) {
             nbt.putString("LootTable", this.getLootTable().toString());
             if (this.getLootTableSeed() != 0L) {
                 nbt.putLong("LootTableSeed", this.getLootTableSeed());
             }
-        } else {
-            ContainerHelper.saveAllItems(nbt, this.getItemStacks());
         }
 
+        ContainerHelper.saveAllItems(nbt, this.getItemStacks()); // Paper - always save the items, table may still remain
     }
 
     default void readChestVehicleSaveData(CompoundTag nbt) {
+        this.lootableData().loadNbt(nbt); // Paper
         this.clearItemStacks();
         if (nbt.contains("LootTable", 8)) {
             this.setLootTable(new ResourceLocation(nbt.getString("LootTable")));
             this.setLootTableSeed(nbt.getLong("LootTableSeed"));
-        } else {
-            ContainerHelper.loadAllItems(nbt, this.getItemStacks());
         }
 
+        ContainerHelper.loadAllItems(nbt, this.getItemStacks()); // Paper - always load the items, table may still remain
     }
 
     default void chestVehicleDestroyed(DamageSource source, Level world, Entity vehicle) {
@@ -96,13 +96,13 @@ public interface ContainerEntity extends Container, MenuProvider {
 
     default void unpackChestVehicleLootTable(@Nullable Player player) {
         MinecraftServer minecraftServer = this.level().getServer();
-        if (this.getLootTable() != null && minecraftServer != null) {
+        if (minecraftServer != null && this.lootableData().shouldReplenish(this.getLootableInventory(), player)) { // Paper - LootTable API
             LootTable lootTable = minecraftServer.getLootData().getLootTable(this.getLootTable());
             if (player != null) {
                 CriteriaTriggers.GENERATE_LOOT.trigger((ServerPlayer)player, this.getLootTable());
             }
 
-            this.setLootTable((ResourceLocation)null);
+            this.lootableData().processRefill(this.getLootableInventory(), player); // Paper - LootTable API
             LootParams.Builder builder = (new LootParams.Builder((ServerLevel)this.level())).withParameter(LootContextParams.ORIGIN, this.position());
             if (player != null) {
                 builder.withLuck(player.getLuck()).withParameter(LootContextParams.THIS_ENTITY, player);
@@ -176,4 +176,14 @@ public interface ContainerEntity extends Container, MenuProvider {
     default boolean isChestVehicleStillValid(Player player) {
         return !this.isRemoved() && this.position().closerThan(player.position(), 8.0D);
     }
+
+    // Paper start - LootTable API
+    default com.destroystokyo.paper.loottable.PaperLootableInventoryData lootableData() {
+        throw new UnsupportedOperationException("Implement this method");
+    }
+
+    default com.destroystokyo.paper.loottable.PaperLootableInventory getLootableInventory() {
+        return ((com.destroystokyo.paper.loottable.PaperLootableInventory) ((net.minecraft.world.entity.Entity) this).getBukkitEntity());
+    }
+    // Paper end - LootTable API
 }
diff --git a/src/main/java/net/minecraft/world/level/block/entity/RandomizableContainerBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/RandomizableContainerBlockEntity.java
index aa4181e59f88be04a3605352fa5ceb3e04149dd3..5aaa0c926df1d68231af9ebc3c5bf5bfe5c112dd 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/RandomizableContainerBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/RandomizableContainerBlockEntity.java
@@ -112,4 +112,13 @@ public abstract class RandomizableContainerBlockEntity extends BaseContainerBloc
             return null;
         }
     }
+
+    // Paper start - LootTable API
+    final com.destroystokyo.paper.loottable.PaperLootableInventoryData lootableData = new com.destroystokyo.paper.loottable.PaperLootableInventoryData(); // Paper
+
+    @Override
+    public com.destroystokyo.paper.loottable.PaperLootableInventoryData lootableData() {
+        return this.lootableData;
+    }
+    // Paper end - LootTable API
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBrushableBlock.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBrushableBlock.java
index 86076a9d2a3b1044c96518cbaeee66d60a8a22c6..c268513bc5719d80e1c3d73de53b85ec7f852fa9 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftBrushableBlock.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBrushableBlock.java
@@ -64,7 +64,7 @@ public class CraftBrushableBlock extends CraftBlockEntityState<BrushableBlockEnt
         this.setLootTable(this.getLootTable(), seed);
     }
 
-    private void setLootTable(LootTable table, long seed) {
+    public void setLootTable(LootTable table, long seed) { // Paper - make public since it overrides a public method
         ResourceLocation key = (table == null) ? null : CraftNamespacedKey.toMinecraft(table.getKey());
         this.getSnapshot().setLootTable(key, seed);
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftLootable.java b/src/main/java/org/bukkit/craftbukkit/block/CraftLootable.java
index 2803e34bd29fd7a965093b507f11b5ee83bc5f09..3b26cb285cae91fac4c9f447ea411b77e9b6ad55 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftLootable.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftLootable.java
@@ -9,7 +9,7 @@ import org.bukkit.craftbukkit.util.CraftNamespacedKey;
 import org.bukkit.loot.LootTable;
 import org.bukkit.loot.Lootable;
 
-public abstract class CraftLootable<T extends RandomizableContainerBlockEntity> extends CraftContainer<T> implements Nameable, Lootable {
+public abstract class CraftLootable<T extends RandomizableContainerBlockEntity> extends CraftContainer<T> implements Nameable, Lootable, com.destroystokyo.paper.loottable.PaperLootableBlockInventory { // Paper
 
     public CraftLootable(World world, T tileEntity) {
         super(world, tileEntity);
@@ -28,35 +28,12 @@ public abstract class CraftLootable<T extends RandomizableContainerBlockEntity>
         }
     }
 
+    // Paper start - move to PaperLootableBlockInventory
     @Override
-    public LootTable getLootTable() {
-        if (this.getSnapshot().lootTable == null) {
-            return null;
-        }
-
-        ResourceLocation key = this.getSnapshot().lootTable;
-        return Bukkit.getLootTable(CraftNamespacedKey.fromMinecraft(key));
-    }
-
-    @Override
-    public void setLootTable(LootTable table) {
-        this.setLootTable(table, this.getSeed());
-    }
-
-    @Override
-    public long getSeed() {
-        return this.getSnapshot().lootTableSeed;
-    }
-
-    @Override
-    public void setSeed(long seed) {
-        this.setLootTable(this.getLootTable(), seed);
-    }
-
-    public void setLootTable(LootTable table, long seed) {
-        ResourceLocation key = (table == null) ? null : CraftNamespacedKey.toMinecraft(table.getKey());
-        this.getSnapshot().setLootTable(key, seed);
+    public net.minecraft.world.RandomizableContainer getRandomizableContainer() {
+        return this.getSnapshot();
     }
+    // Paper end - move to PaperLootableBlockInventory
 
     @Override
     public abstract CraftLootable<T> copy();
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftChestBoat.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftChestBoat.java
index cc3f70fafea2d5c3a878cfe3e0a2db39ae713bf6..19cbf1881f081f0a036b6f42e6471f87f59b109e 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftChestBoat.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftChestBoat.java
@@ -10,8 +10,7 @@ import org.bukkit.craftbukkit.util.CraftNamespacedKey;
 import org.bukkit.inventory.Inventory;
 import org.bukkit.loot.LootTable;
 
-public class CraftChestBoat extends CraftBoat implements org.bukkit.entity.ChestBoat {
-
+public class CraftChestBoat extends CraftBoat implements org.bukkit.entity.ChestBoat, com.destroystokyo.paper.loottable.PaperLootableEntityInventory { // Paper
     private final Inventory inventory;
 
     public CraftChestBoat(CraftServer server, ChestBoat entity) {
@@ -34,35 +33,5 @@ public class CraftChestBoat extends CraftBoat implements org.bukkit.entity.Chest
         return this.inventory;
     }
 
-    @Override
-    public void setLootTable(LootTable table) {
-        this.setLootTable(table, this.getSeed());
-    }
-
-    @Override
-    public LootTable getLootTable() {
-        ResourceLocation nmsTable = this.getHandle().getLootTable();
-        if (nmsTable == null) {
-            return null; // return empty loot table?
-        }
-
-        NamespacedKey key = CraftNamespacedKey.fromMinecraft(nmsTable);
-        return Bukkit.getLootTable(key);
-    }
-
-    @Override
-    public void setSeed(long seed) {
-        this.setLootTable(this.getLootTable(), seed);
-    }
-
-    @Override
-    public long getSeed() {
-        return this.getHandle().getLootTableSeed();
-    }
-
-    private void setLootTable(LootTable table, long seed) {
-        ResourceLocation newKey = (table == null) ? null : CraftNamespacedKey.toMinecraft(table.getKey());
-        this.getHandle().setLootTable(newKey);
-        this.getHandle().setLootTableSeed(seed);
-    }
+   // Paper - moved loot table logic to PaperLootableEntityInventory
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftMinecartChest.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftMinecartChest.java
index fd42f0b20132d08039ca7735d31a61806a6b07dc..b1a708de6790bbe336202b13ab862ced78de084f 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftMinecartChest.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftMinecartChest.java
@@ -7,7 +7,7 @@ import org.bukkit.entity.minecart.StorageMinecart;
 import org.bukkit.inventory.Inventory;
 
 @SuppressWarnings("deprecation")
-public class CraftMinecartChest extends CraftMinecartContainer implements StorageMinecart {
+public class CraftMinecartChest extends CraftMinecartContainer implements StorageMinecart, com.destroystokyo.paper.loottable.PaperLootableEntityInventory { // Paper
     private final CraftInventory inventory;
 
     public CraftMinecartChest(CraftServer server, MinecartChest entity) {
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftMinecartContainer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftMinecartContainer.java
index 313ee5c8737b2e57f9b5db6512c1871766b2ccd4..1295e3ba6929acd82ab0cdd76b8b472b91e327e0 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftMinecartContainer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftMinecartContainer.java
@@ -10,7 +10,7 @@ import org.bukkit.craftbukkit.util.CraftNamespacedKey;
 import org.bukkit.loot.LootTable;
 import org.bukkit.loot.Lootable;
 
-public abstract class CraftMinecartContainer extends CraftMinecart implements Lootable {
+public abstract class CraftMinecartContainer extends CraftMinecart implements com.destroystokyo.paper.loottable.PaperLootableEntityInventory { // Paper
 
     public CraftMinecartContainer(CraftServer server, AbstractMinecart entity) {
         super(server, entity);
@@ -21,34 +21,5 @@ public abstract class CraftMinecartContainer extends CraftMinecart implements Lo
         return (AbstractMinecartContainer) this.entity;
     }
 
-    @Override
-    public void setLootTable(LootTable table) {
-        this.setLootTable(table, this.getSeed());
-    }
-
-    @Override
-    public LootTable getLootTable() {
-        ResourceLocation nmsTable = this.getHandle().lootTable;
-        if (nmsTable == null) {
-            return null; // return empty loot table?
-        }
-
-        NamespacedKey key = CraftNamespacedKey.fromMinecraft(nmsTable);
-        return Bukkit.getLootTable(key);
-    }
-
-    @Override
-    public void setSeed(long seed) {
-        this.setLootTable(this.getLootTable(), seed);
-    }
-
-    @Override
-    public long getSeed() {
-        return this.getHandle().lootTableSeed;
-    }
-
-    public void setLootTable(LootTable table, long seed) {
-        ResourceLocation newKey = (table == null) ? null : CraftNamespacedKey.toMinecraft(table.getKey());
-        this.getHandle().setLootTable(newKey, seed);
-    }
+    // Paper - moved loot table logic to PaperLootableEntityInventory
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftMinecartHopper.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftMinecartHopper.java
index 39427b4f284e9402663be2b160ccb5f03f8b91da..17f5684cba9d3ed22d9925d1951520cc4751dfe2 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftMinecartHopper.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftMinecartHopper.java
@@ -6,7 +6,7 @@ import org.bukkit.craftbukkit.inventory.CraftInventory;
 import org.bukkit.entity.minecart.HopperMinecart;
 import org.bukkit.inventory.Inventory;
 
-public final class CraftMinecartHopper extends CraftMinecartContainer implements HopperMinecart {
+public final class CraftMinecartHopper extends CraftMinecartContainer implements HopperMinecart, com.destroystokyo.paper.loottable.PaperLootableEntityInventory { // Paper
     private final CraftInventory inventory;
 
     public CraftMinecartHopper(CraftServer server, MinecartHopper entity) {
