From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Janet Blackquill <uhhadd@gmail.com>
Date: Fri, 26 Apr 2024 23:46:35 -0400
Subject: [PATCH] Implement preliminary API for working with 'new' mob AI
 system


diff --git a/src/main/java/io/papermc/paper/entity/ai/PaperActivity.java b/src/main/java/io/papermc/paper/entity/ai/PaperActivity.java
new file mode 100644
index 0000000000000000000000000000000000000000..8724ac343b62f29020aa06093fc01787619d64fb
--- /dev/null
+++ b/src/main/java/io/papermc/paper/entity/ai/PaperActivity.java
@@ -0,0 +1,36 @@
+package io.papermc.paper.entity.ai;
+
+import net.minecraft.world.entity.schedule.Activity;
+import net.minecraft.core.registries.Registries;
+import org.bukkit.NamespacedKey;
+import org.bukkit.Registry;
+import org.bukkit.craftbukkit.CraftRegistry;
+import org.bukkit.craftbukkit.util.Handleable;
+
+public class PaperActivity implements io.papermc.paper.entity.ai.Activity, Handleable<Activity> {
+    final private NamespacedKey key;
+    final private Activity handle;
+
+    public static io.papermc.paper.entity.ai.Activity minecraftToBukkit(Activity minecraft) {
+        return CraftRegistry.minecraftToBukkit(minecraft, Registries.ACTIVITY, Registry.ACTIVITY);
+    }
+    public static Activity bukkitToMinecraft(io.papermc.paper.entity.ai.Activity bukkit) {
+        return CraftRegistry.bukkitToMinecraft(bukkit);
+    }
+
+    public PaperActivity(NamespacedKey key, Activity handle) {
+        this.key = key;
+        this.handle = handle;
+    }
+
+    @Override
+    public Activity getHandle() {
+        return this.handle;
+    }
+
+    @Override
+    public NamespacedKey getKey() {
+        if (true) return java.util.Objects.requireNonNull(org.bukkit.Registry.ACTIVITY.getKey(this), () -> this + " doesn't have a key");
+        return this.key;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/entity/ai/PaperBrain.java b/src/main/java/io/papermc/paper/entity/ai/PaperBrain.java
new file mode 100644
index 0000000000000000000000000000000000000000..dfc84db49790e65bae01623b232b322e319d3d38
--- /dev/null
+++ b/src/main/java/io/papermc/paper/entity/ai/PaperBrain.java
@@ -0,0 +1,71 @@
+package io.papermc.paper.entity.ai;
+
+import java.util.List;
+import org.bukkit.entity.LivingEntity;
+import net.minecraft.world.entity.ai.Brain;
+import net.minecraft.world.entity.ai.memory.MemoryModuleType;
+import net.minecraft.world.entity.ai.memory.MemoryStatus;
+import com.google.common.collect.ImmutableList;
+import net.minecraft.world.entity.ai.behavior.BehaviorControl;
+import org.jetbrains.annotations.NotNull;
+import org.bukkit.entity.Entity;
+import org.bukkit.craftbukkit.entity.CraftEntity;
+import org.bukkit.Location;
+import net.minecraft.world.entity.ai.memory.WalkTarget;
+import org.bukkit.craftbukkit.util.CraftLocation;
+
+public class PaperBrain<Paper extends LivingEntity, Minecraft extends net.minecraft.world.entity.LivingEntity> implements io.papermc.paper.entity.ai.Brain<Paper> {
+    public final Brain<Minecraft> handle;
+
+    public PaperBrain(Brain<Minecraft> handle) {
+        this.handle = handle;
+    }
+    public Brain<Minecraft> getHandle() {
+        return this.handle;
+    }
+
+    @Override
+    public void useDefaultActivity() {
+        this.getHandle().useDefaultActivity();
+    }
+
+    @Override
+    public void useActivityIfPossible(@NotNull Activity activity) {
+        this.getHandle().setActiveActivityIfPossible(((PaperActivity)activity).getHandle());
+    }
+
+    @Override
+    public void setTasksForActivity(@NotNull Activity activity, int begin, @NotNull List<Task<Paper>> tasks) {
+        this.getHandle().addActivity(
+            ((PaperActivity)activity).getHandle(),
+            begin,
+            ImmutableList.<BehaviorControl<Minecraft>>copyOf(tasks.stream().map(task -> ((PaperTask<Paper, Minecraft>)task).getHandle()).iterator())
+        );
+    }
+
+    @Override
+    public void clearActivities() {
+        this.getHandle().removeAllBehaviors();
+    }
+
+    @Override
+    public void setDefaultActivity(@NotNull Activity activity) {
+        this.getHandle().setDefaultActivity(((PaperActivity)activity).getHandle());
+    }
+
+    @Override
+    public boolean isActive(@NotNull Activity activity) {
+        return this.getHandle().isActive(((PaperActivity)activity).getHandle());
+    }
+
+    @Override
+    public void setWalkTarget(@NotNull Location location, float speed, int completeWithinDistance) {
+        this.getHandle().setMemory(MemoryModuleType.WALK_TARGET, new WalkTarget(CraftLocation.toBlockPosition(location), speed, completeWithinDistance));
+    }
+
+    @Override
+    public void setWalkTarget(@NotNull Entity entity, float speed, int completeWithinDistance) {
+        this.getHandle().setMemory(MemoryModuleType.WALK_TARGET, new WalkTarget(((CraftEntity)entity).getHandle(), speed, completeWithinDistance));
+    }
+}
+
diff --git a/src/main/java/io/papermc/paper/entity/ai/PaperTask.java b/src/main/java/io/papermc/paper/entity/ai/PaperTask.java
new file mode 100644
index 0000000000000000000000000000000000000000..870ff6a179b62302c1b6dbf603fd5621396dd964
--- /dev/null
+++ b/src/main/java/io/papermc/paper/entity/ai/PaperTask.java
@@ -0,0 +1,16 @@
+package io.papermc.paper.entity.ai;
+
+import org.bukkit.entity.LivingEntity;
+
+import net.minecraft.world.entity.ai.behavior.BehaviorControl;
+
+public class PaperTask<Paper extends LivingEntity, Minecraft extends net.minecraft.world.entity.LivingEntity> implements io.papermc.paper.entity.ai.Task {
+    final private BehaviorControl<Minecraft> handle;
+
+    public PaperTask(BehaviorControl<Minecraft> handle) {
+        this.handle = handle;
+    }
+    public BehaviorControl<Minecraft> getHandle() {
+        return this.handle;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/io/papermc/paper/entity/ai/PaperTasks.java b/src/main/java/io/papermc/paper/entity/ai/PaperTasks.java
new file mode 100644
index 0000000000000000000000000000000000000000..433fcfdbb0b0112f2e80e71fc9bea19ad62d32b5
--- /dev/null
+++ b/src/main/java/io/papermc/paper/entity/ai/PaperTasks.java
@@ -0,0 +1,54 @@
+package io.papermc.paper.entity.ai;
+
+import org.bukkit.Location;
+import org.bukkit.entity.Mob;
+import org.bukkit.entity.LivingEntity;
+import org.bukkit.entity.memory.MemoryKey;
+import net.minecraft.world.entity.ai.behavior.BehaviorControl;
+import net.minecraft.world.entity.ai.behavior.MoveToTargetSink;
+import net.minecraft.world.entity.ai.behavior.LookAtTargetSink;
+import net.minecraft.world.entity.ai.behavior.Swim;
+import net.minecraft.world.entity.ai.behavior.AnimalPanic;
+import net.minecraft.world.entity.ai.behavior.SetEntityLookTarget;
+import net.minecraft.world.entity.ai.behavior.SetWalkTargetFromLookTarget;
+import net.minecraft.world.entity.ai.behavior.RunOne;
+import org.bukkit.craftbukkit.entity.memory.CraftMemoryKey;
+import org.jetbrains.annotations.NotNull;
+import java.util.function.Predicate;
+import java.util.function.Function;
+import java.util.Map;
+import java.util.List;
+import java.util.ArrayList;
+import com.mojang.datafixers.util.Pair;
+
+public class PaperTasks implements io.papermc.paper.entity.ai.Tasks {
+    public <Entity extends Mob> @NotNull Task<Entity> walkToWalkTarget(int minRunTime, int maxRunTime) {
+        return new PaperTask(new MoveToTargetSink(minRunTime, maxRunTime));
+    }
+    public <Entity extends Mob> @NotNull Task<Entity> swimIfInWater(float chance) {
+        return new PaperTask(new Swim(chance));
+    }
+    public <Entity extends Mob> @NotNull Task<Entity> panicOnDamage(float speed) {
+        return new PaperTask(new AnimalPanic(speed));
+    }
+    public <Entity extends LivingEntity> @NotNull Task<Entity> setLookTarget(Predicate<LivingEntity> predicate, float maximumDistance) {
+        return new PaperTask(SetEntityLookTarget.create(nmsEntity -> predicate.test(nmsEntity.getBukkitLivingEntity()), maximumDistance));
+    }
+    public <Entity extends LivingEntity> @NotNull Task<Entity> setWalkTargetToLookTarget(Predicate<LivingEntity> predicate, Function<LivingEntity, Float> speed, int completionRange) {
+        return new PaperTask(SetWalkTargetFromLookTarget.create(
+            nmsEntity -> predicate.test(nmsEntity.getBukkitLivingEntity()),
+            nmsEntity -> speed.apply(nmsEntity.getBukkitLivingEntity()),
+            completionRange
+        ));
+    }
+    public <Entity extends Mob> @NotNull Task<Entity> lookAtLookTarget(int minRunTime, int maxRunTime) {
+        return new PaperTask(new LookAtTargetSink(minRunTime, maxRunTime));
+    }
+    public <Bukkit extends LivingEntity> @NotNull Task<Bukkit> runOneOf(Map<Task<? super Bukkit>, Integer> tasks) {
+        List<Pair<BehaviorControl<? super net.minecraft.world.entity.LivingEntity>, Integer>> mcTasks = new ArrayList<>(tasks.size());
+        for (Map.Entry<Task<? super Bukkit>, Integer> entry : tasks.entrySet()) {
+            mcTasks.add(new Pair(((PaperTask)entry.getKey()).getHandle(), entry.getValue()));
+        }
+        return new PaperTask(new RunOne(mcTasks));
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/net/minecraft/world/entity/ai/Brain.java b/src/main/java/net/minecraft/world/entity/ai/Brain.java
index afbb027021acfbe25d534a84f1750e420bbde6e0..8ca8152a98710ee256fc1a11be6cd932bc6695fb 100644
--- a/src/main/java/net/minecraft/world/entity/ai/Brain.java
+++ b/src/main/java/net/minecraft/world/entity/ai/Brain.java
@@ -79,7 +79,7 @@ public class Brain<E extends LivingEntity> {
                     }
 
                     public <T> DataResult<Brain<E>> decode(DynamicOps<T> dynamicOps, MapLike<T> mapLike) {
-                        MutableObject<DataResult<Builder<Brain.MemoryValue<?>>>> mutableObject = new MutableObject<>(
+                        MutableObject<DataResult<Builder<Brain.MemoryValue<?>>>> dataResultMutableObject = new MutableObject<>( // Paper - fix decompilation name collision
                             DataResult.success(ImmutableList.builder())
                         );
                         mapLike.entries()
@@ -91,10 +91,10 @@ public class Brain<E extends LivingEntity> {
                                     DataResult<? extends Brain.MemoryValue<?>> dataResult2 = dataResult.flatMap(
                                         memoryType -> this.captureRead((MemoryModuleType<T>)memoryType, dynamicOps, (T)pair.getSecond())
                                     );
-                                    mutableObject.setValue(mutableObject.getValue().apply2(Builder::add, dataResult2));
+                                    dataResultMutableObject.setValue(dataResultMutableObject.getValue().apply2(Builder::add, dataResult2)); // Paper - fix decompilation name collision
                                 }
                             );
-                        ImmutableList<Brain.MemoryValue<?>> immutableList = mutableObject.getValue()
+                        ImmutableList<Brain.MemoryValue<?>> immutableList = dataResultMutableObject.getValue() // Paper - fix decompilation name collision
                             .resultOrPartial(Brain.LOGGER::error)
                             .map(Builder::build)
                             .orElseGet(ImmutableList::of);
@@ -180,28 +180,30 @@ public class Brain<E extends LivingEntity> {
     }
 
     <U> void setMemoryInternal(MemoryModuleType<U> type, Optional<? extends ExpirableValue<?>> memory) {
-        if (this.memories.containsKey(type)) {
+        // Paper start - allow custom memories to be set on any brain
+        // if (this.memories.containsKey(type)) {
             if (memory.isPresent() && this.isEmptyCollection(memory.get().getValue())) {
                 this.eraseMemory(type);
             } else {
                 this.memories.put(type, memory);
             }
-        }
+        // }
+        // Paper end - allow custom memories to be set on any brain
     }
 
     public <U> Optional<U> getMemory(MemoryModuleType<U> type) {
-        Optional<? extends ExpirableValue<?>> optional = this.memories.get(type);
+        Optional<? extends ExpirableValue<U>> optional = (Optional<? extends ExpirableValue<U>>)this.memories.get(type); // Paper - decompilation fix
         if (optional == null) {
             throw new IllegalStateException("Unregistered memory fetched: " + type);
         } else {
-            return optional.map(ExpirableValue::getValue);
+            return optional.map(x -> x.getValue()); // Paper - decompilation fix
         }
     }
 
     @Nullable
     public <U> Optional<U> getMemoryInternal(MemoryModuleType<U> type) {
-        Optional<? extends ExpirableValue<?>> optional = this.memories.get(type);
-        return optional == null ? null : optional.map(ExpirableValue::getValue);
+        Optional<? extends ExpirableValue<U>> optional = (Optional<? extends ExpirableValue<U>>)this.memories.get(type); // Paper - decompilation fix
+        return optional == null ? null : optional.map(x -> x.getValue()); // Paper - decompilation fix
     }
 
     public <U> long getTimeUntilExpiry(MemoryModuleType<U> type) {
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftRegistry.java b/src/main/java/org/bukkit/craftbukkit/CraftRegistry.java
index 4fc02698a9312496e7f9bce1c64f317374d2a42f..05e3feb65dc9288c8288c1ecef7426bed018c57e 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftRegistry.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftRegistry.java
@@ -125,6 +125,11 @@ public class CraftRegistry<B extends Keyed, M> implements Registry<B> {
             return new io.papermc.paper.world.structure.PaperConfiguredStructure.LegacyRegistry(registryHolder.registryOrThrow(Registries.STRUCTURE));
         }
         // Paper end
+        // Paper start - activity registry
+        if (bukkitClass == io.papermc.paper.entity.ai.Activity.class) {
+            return new CraftRegistry<>(io.papermc.paper.entity.ai.Activity.class, registryHolder.registryOrThrow(Registries.ACTIVITY), io.papermc.paper.entity.ai.PaperActivity::new);
+        }
+        // Paper end - activity registry
 
         return null;
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index c490a29bcf7410bc54959ee71375605964379ed5..b54752d076d187f23aafa90514b62c4301dca8ab 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -3259,4 +3259,17 @@ public final class CraftServer implements Server {
     }
 
     // Paper end
+    // Paper begin - activities and tasks AI API
+    private final io.papermc.paper.entity.ai.Tasks tasks = new io.papermc.paper.entity.ai.PaperTasks();
+
+    @Override
+    public io.papermc.paper.entity.ai.Tasks getTasks() {
+        return this.tasks;
+    }
+
+    @Override
+    public <E extends org.bukkit.entity.LivingEntity> io.papermc.paper.entity.ai.Brain<E> getBrain(E entity) {
+        return new io.papermc.paper.entity.ai.PaperBrain(((org.bukkit.craftbukkit.entity.CraftLivingEntity)entity).getHandle().getBrain());
+    }
+    // Paper end - activities and tasks AI API
 }
diff --git a/src/test/java/org/bukkit/support/provider/RegistriesArgumentProvider.java b/src/test/java/org/bukkit/support/provider/RegistriesArgumentProvider.java
index 167cd003a52b722772708a528d724db14c89c35a..c4ee058f4ea6f320b945056f9848afdeb2ae1fc2 100644
--- a/src/test/java/org/bukkit/support/provider/RegistriesArgumentProvider.java
+++ b/src/test/java/org/bukkit/support/provider/RegistriesArgumentProvider.java
@@ -43,6 +43,7 @@ public class RegistriesArgumentProvider implements ArgumentsProvider {
         DATA.add(Arguments.of(TrimMaterial.class, Registries.TRIM_MATERIAL, CraftTrimMaterial.class, net.minecraft.world.item.armortrim.TrimMaterial.class));
         DATA.add(Arguments.of(TrimPattern.class, Registries.TRIM_PATTERN, CraftTrimPattern.class, net.minecraft.world.item.armortrim.TrimPattern.class));
         DATA.add(Arguments.of(DamageType.class, Registries.DAMAGE_TYPE, CraftDamageType.class, net.minecraft.world.damagesource.DamageType.class));
+        DATA.add(Arguments.of(io.papermc.paper.entity.ai.Activity.class, Registries.ACTIVITY, io.papermc.paper.entity.ai.PaperActivity.class, net.minecraft.world.entity.schedule.Activity.class)); // Paper - add activity registry
     }
 
     @Override
